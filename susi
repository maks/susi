#!/usr/bin/env node

var fs = require('fs'),
    commonmark = require('commonmark'),
    moment = require('moment'),
    Mustache = require('mustache'),
    path = require('path');

var args = process.argv.slice(2);

var layoutPathPrefix = path.resolve(args[2]); //expect it to have trailing slash
var partialsPathPrefix = path.resolve(args[3]); //expect it to have trailing slash

var CONFIG_FILE_PATH = "_config.json";

if (layoutPathPrefix.slice(-1) !== '/') {
    layoutPathPrefix += '/';
}
if (partialsPathPrefix.slice(-1) !== '/') {
    partialsPathPrefix += '/';
}

function stripExtension(fileName) {
  return fileName.substr(0, fileName.lastIndexOf('.'));
}

function renderToHtml(config, inputFilePath, outputFilePath) {
  fs.readFile(inputFilePath, 'utf8', function(fileErr, fileContent) {
    var res = processMarkupContent(fileContent);
    if(res.frontmatter) {
      //add globals
      res.frontmatter = Object.assign(config, res.frontmatter);

      res.frontmatter.date = res.frontmatter.date ? moment(res.frontmatter.date).format('MMMM Do YYYY') : moment().format('MMMM Do YYYY');
      res.frontmatter.layout = res.frontmatter.layout || "page"; //default to page layout
      var layoutHTML = fs.readFileSync(layoutPathPrefix+res.frontmatter.layout+".html", 'utf8');

      //first pull in all includes for use as partials
      var partials = readFilesSync(partialsPathPrefix);

      var parser   = new commonmark.Parser();
      var renderer = new commonmark.HtmlRenderer();

      //first process markdown
      res.frontmatter.contents = renderer.render(parser.parse(String(res.content)));

      //and then process  mustache syntax, including using partials
      var finalHTML = Mustache.render(String(layoutHTML), res.frontmatter, partials);

      fs.writeFile(outputFilePath, finalHTML, 'utf8');
      console.log("converted: "+inputFilePath+"->"+outputFilePath);
    } else {
      console.warn(inputFilePath + " is missing the Frontmatter section!")
    }
  });
}

/**
 * Read in all file in dirname
 * ref: http://stackoverflow.com/a/10049704/85472
 */
function readFilesSync(dirname) {
  var filenames = fs.readdirSync(dirname);
  var data = {};
  filenames.forEach(function(filename) {
      data[filename.replace(".","_")] = fs.readFileSync(dirname + filename, 'utf-8');
  });
  return data;
}

function convertFilesInPath(config, inputPath, outputPath) {

  //make sure paths are slash terminated
  inputPath = (inputPath.lastIndexOf('/') === inputPath.length -1) ? inputPath : inputPath + '/' ;
  outputPath = (outputPath.lastIndexOf('/') === outputPath.length -1) ? outputPath : outputPath + '/' ;

  fs.readdir(path.resolve(inputPath), function(pathErr, files) {
    files.forEach(function(file) {
      if(fs.lstatSync(inputPath + file).isDirectory()) {
        convertFilesInPath(config, inputPath + file, outputPath+ file);
        return;
      } else if (file.substr(-2) != 'md') {
        return;
      }

      if(!fs.existsSync(outputPath)) {
        fs.mkdirSync(outputPath);
      }

      renderToHtml(config, inputPath+ file, outputPath + stripExtension(file) + '.html');
    });
  });
}

/**
  * returns an array, first object is the JSON frontmatter as an object, second is the
  * text with the front matter stripped out
  */
function processMarkupContent(data) {
  //strip out json front-matter
  var parts = data.split(/---/);
  var jsonFM;
  if (parts[0].length < 1) {
    throw new Error("missing frontmatter");
  }
  try {
    jsonFM = JSON.parse(parts[0]);
  } catch(e) {
    console.error("[frontmatter] err parsing json:"+parts[0], e);
  }
  parts.shift();
  return {
    frontmatter : jsonFM,
    content: parts.join('---')
  };
}

// read in global config
fs.readFile(CONFIG_FILE_PATH, 'utf8', function(fileErr, fileContent) {
    if (fileErr) {
        console.error("Missing: "+CONFIG_FILE_PATH);
        process.exit(1);
    }
    var config = JSON.parse(fileContent);
    convertFilesInPath(config, args[0], args[1]);
});
